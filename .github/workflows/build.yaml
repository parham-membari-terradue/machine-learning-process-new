name: build
on:
  push:
    branches:
      - master
      - main
    paths:
      - 'inference/**'
      - .github/**
      - 'training/**'
      - codemeta.json

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-python@v2
        with:
          python-version: 3.x
      - run: pip install cwltool
      - run: cwltool --validate training/app-package/tile-sat-training.cwl
      - run: cwltool --validate inference/app-package/tile-sat-inference.cwl

  version:
    needs: validate
    runs-on: ubuntu-latest
    outputs:
      app-version: ${{ steps.set-version.outputs.version }}
    steps:
      - uses: actions/checkout@v2
      - run: echo "APP_VERSION=$(cat codemeta.json | jq -r .version )" >> $GITHUB_ENV
      - run: echo "App version is $APP_VERSION"
      - id: set-version
        run: echo "version=${APP_VERSION}" >> $GITHUB_ENV

  container-build:
    needs: version
    runs-on: ubuntu-latest
    permissions:
        contents: read
        packages: write
    strategy:
      matrix:
        include:
          - step: training
            path: make-ml-model
          - step: inference
            path: make-inference

    steps:
        - name: Checkout repository
          uses: actions/checkout@v2

        - name: Authenticate to GitHub Container Registry
          run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

        - name: Build & Push Docker Image
          run: |
            IMAGE_ID=ghcr.io/parham-membari-terradue/machine-learning-process-new/${{ matrix.step }}
            DOCKERFILE_PATH=${{ matrix.step }}/${{ matrix.path }}/Dockerfile
            CONTEXT_PATH=${{ matrix.step }}/${{ matrix.path }}

            echo "Building Docker image from: $DOCKERFILE_PATH"

            docker build "$CONTEXT_PATH" --file "$DOCKERFILE_PATH" --tag "${{ matrix.step }}"
            docker tag "${{ matrix.step }}" "$IMAGE_ID:${{ needs.version.outputs.app-version }}"
            docker push "$IMAGE_ID:${{ needs.version.outputs.app-version }}"

  create-release:
    needs:
      - container-build
      - version
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      upload_url: ${{ steps.set-upload-url.outputs.upload_url }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Check if Tag Already Exists
        id: check_tag
        run: |
          git fetch --tags
          if git ls-remote --tags origin | grep -q "refs/tags/${{ needs.version.outputs.app-version }}"; then
            echo "Tag already exists. Creating a new release with a different version."
            echo "tag_exists=true" >> $GITHUB_ENV
          else
            echo "Tag does not exist. Proceeding with release creation."
            echo "tag_exists=false" >> $GITHUB_ENV
          fi

      - name: Create New Version if Needed
        if: env.tag_exists == 'true'
        run: |
          NEW_VERSION=$(echo "${{ needs.version.outputs.app-version }}" | awk -F. -v OFS=. '{$NF += 1 ; print}')
          echo "New version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_ENV

      - name: Create GitHub Release
        uses: actions/create-release@v1
        id: create_release
        with:
          draft: false
          prerelease: false
          release_name: ${{ env.version }}
          tag_name: ${{ env.version }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Set Upload URL
        run: echo "upload_url=${{ steps.create_release.outputs.upload_url }}" >> $GITHUB_ENV

  publish-artifacts:
    needs:
      - create-release
      - version
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - name: tile-sat-training
            path: training/app-package/tile-sat-training.cwl
          - name: tile-sat-inference
            path: inference/app-package/tile-sat-inference.cwl
    permissions:
        contents: read
        packages: write
    steps:
      - uses: actions/checkout@v2

      - name: Verify CWL Files Exist
        run: |
          if [ ! -f "${{ matrix.path }}" ]; then
            echo "ERROR: CWL file does not exist: ${{ matrix.path }}"
            exit 1
          fi

      - name: Update CWL files with Docker Image Tags
        run: |
          for step in training inference
          do
            tag="ghcr.io/parham-membari-terradue/machine-learning-process-new/${step}:${{ needs.version.outputs.app-version }}"
            docker pull ${tag}
            shatag=$( docker inspect ${tag} | yq -r '.[0]["RepoDigests"][0]' )
            cwl_path="${{ matrix.path }}"

            echo "âœ… Updating CWL file: $cwl_path with Docker tag: $shatag"
            s="${step}" t="${shatag}" yq -i eval '(.$graph[] | select (.id == env(s)) ).hints.DockerRequirement.dockerPull = env(t)' "$cwl_path"
          done

      - name: Update Metadata in CWL files
        run: |
          cwl_path="${{ matrix.path }}"
          r=$( cat codemeta.json | jq -r ".codeRepository" ) yq -i eval '."s:codeRepository" = {"URL" : env(r)}' "$cwl_path"
          v="${{ needs.version.outputs.app-version }}" yq -i eval '."s:softwareVersion" = env(v)' "$cwl_path"
          n=$(cat codemeta.json | jq -r '(.author[0].givenName + " " + .author[0].familyName)') \
          e=$(cat codemeta.json | jq -r '.author[0].email') \
          a=$(cat codemeta.json | jq -r '.author[0].affiliation["name"]') \
          yq eval -i  '."s:author" += [{"class": "s:Person", "s.name": env(n), "s.email": env(e), "s.affiliation": env(a)}]' "$cwl_path"

      - name: Cleanup downloads folder
        run: rm -rf downloads/*

      - name: Prepare Artifacts for Upload
        run: |
          mkdir -p downloads
          cp "${{ matrix.path }}" "downloads/${{ matrix.name }}.${{ needs.version.outputs.app-version }}.cwl"

      - name: Upload CWL as Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: application-package-${{ matrix.name }}
          path: downloads
          overwrite: true

      - name: Upload Release Assets
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: downloads/${{ matrix.name }}.${{ needs.version.outputs.app-version }}.cwl
          asset_name: ${{ matrix.name }}.${{ needs.version.outputs.app-version }}.cwl
          asset_content_type: text/yaml
